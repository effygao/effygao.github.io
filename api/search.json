[{"id":"71ccfa0a8479931c66dcff584c51ed03","title":"计算机组成原理笔记","content":"CPU性能响应时间：指的就是，我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。\n吞吐率：在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。\n我们一般把性能，定义成响应时间的倒数，也就是：\n性能 &#x3D; 1&#x2F;响应时间\n\n程序运行的时间程序运行的时间&#x3D;程序运行结束的时间-程序开始运行的时间\n\n但是，计算机可能同时运行着好多个程序，CPU实际上不停地在各个程序之间进行切换。在这些走掉的时间里面，很可能CPU切换去运行别的程序了。所以这个时间并不准。\n我们使用time命令统计运行时间：\n$ time seq\n  1000000 | wc -l \n1000000 \nreal 0m0.101s \nuser 0m0.031s \nsys  0m0.016s\n\n其中real就是Wall Clock Time，而程序实际花费的CPU执行时间，就是user time加上sys time。\n我们下面对程序的CPU执行时间进行拆解：\n程序的CPU执行时间&#x3D;CPU时钟周期数×时钟周期时间\n\n时钟周期时间：如果一台电脑的主频是2.8GHz，那么可以简单认为，CPU在1秒时间内，可以执行的简单指令的数量是2.8G条。在这个2.8GHz的CPU上，这个时钟周期时间，就是1&#x2F;2.8G。\n对于上面的公式：CPU时钟周期数还可以拆解成指令数×每条指令的平均时钟周期数Cycles Per Instruction，简称CPI）。\n程序的CPU执行时间&#x3D;指令数×CPI×Clock Cycle Time\n\n并行优化由于通过提升CPU频率已经达到瓶颈，所以开始推出多核CPU，通过提升“吞吐率”而不是“响应时间”，来达到目的。\n但是，并不是所有问题，都可以通过并行提高性能来解决。如果想要使用这种思想，需要满足这样几个条件。\n1、需要进行的计算，本身可以分解成几个可以并行的任务。2、需要能够分解好问题，并确保几个人的结果能够汇总到一起。3、在“汇总”这个阶段，是没有办法并行进行的，还是得顺序执行，一步一步来。\n所以并行计算涉及到了一个阿姆达尔定律（Amdahl’s Law）。\n对于一个程序进行优化之后，处理器并行运算之后效率提升的情况。具体可以用这样一个公式来表示：\n优化后的执行时间 &#x3D; 受优化影响的执行时间&#x2F;加速倍数+不受影响的执行时间\n比如做一段数据的计算， 本来如果整个计算单核完成需要120ns，但是我们可以将这个任务拆分成4个，最后再汇总加起来。\n如果每个任务单独计算需要25ns，加起来汇总需要20ns，那么4个任务并行计算需要100&#x2F;4+20&#x3D;25ns。\n即使我们增加更多的并行度来提供加速倍数，比如有100个CPU，整个时间也需要100&#x2F;100+20&#x3D;21ns。\n\n从编译到汇编，代码怎么变成机器码？如下C语言程序例子：\n&#x2F;&#x2F; test.cint main()&#123;\n  int a &#x3D; 1;\n  int b &#x3D; 2;\n  a &#x3D; a + b;\n&#125;\n我们给两个变量 a、b分别赋值1、2，然后再将a、b两个变量中的值加在一起，重新赋值给了a整个变量。\n要让这段程序在一个Linux操作系统上跑起来，我们需要把整个程序翻译成一个汇编语言（ASM，Assembly Language）的程序，这个过程我们一般叫编译（Compile）成汇编代码。\n针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）。这些机器码由“0”和“1”组成的机器语言表示。这一条条机器码，就是一条条的计算机指令。这样一串串的16进制数字，就是我们CPU能够真正认识的计算机指令。\n\n汇编代码其实就是“给程序员看的机器码”，也正因为这样，机器码和汇编代码是一一对应的。我们人类很容易记住add、mov这些用英文表示的指令，而8b 45 f8这样的指令，由于很难一下子看明白是在干什么，所以会非常难以记忆。所以我们需要汇编代码。\n程序指令指令是如何被执行的一个CPU里面会有很多种不同功能的寄存器。我这里给你介绍三种比较特殊的。\n1、PC寄存器（Program Counter Register），也叫指令地址寄存器（Instruction Address Register）。它就是用来存放下一条需要执行的计算机指令的内存地址。\n2、指令寄存器（Instruction Register），用来存放当前正在执行的指令。\n3、条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放CPU进行算术或者逻辑计算的结果。\n\n实际上，一个程序执行的时候，CPU会根据PC寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。\n程序的执行和跳转现在就来看一个包含if…else的简单程序。\n&#x2F;&#x2F; test.c\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt; \nint main() &#123; \n    srand(time(NULL)); \n    int r &#x3D; rand() % 2; \n    int a &#x3D; 10; \n    if (r &#x3D;&#x3D; 0) &#123; \n        a &#x3D; 1; \n        &#125; else &#123; \n        a &#x3D; 2; \n&#125;\n\n把这个程序编译成汇编代码。\nif (r &#x3D;&#x3D; 0)\n3b: 83 7d fc 00     cmp DWORD PTR [rbp-0x4],0x0 \n3f: 75 09           jne 4a &lt;main+0x4a&gt;\n &#123;\n     a &#x3D; 1;\n41: c7 45 f8 01 00 00 00      mov DWORD PTR [rbp-0x8],0x1 \n48: eb 07                     jmp 51 &lt;main+0x51&gt;\n    &#125; \n    else \n    &#123;\n         a &#x3D; 2;\n4a: c7 45 f8 02 00 00 00   mov DWORD PTR [rbp-0x8],0x2\n51: b8 00 00 00 00         mov eax,0x0\n&#125;\n\n可以看到，这里对于r &#x3D;&#x3D; 0的条件判断，被编译成了cmp和jne这两条指令。\n对于：\ncmp DWORD PTR [rbp-0x4],0x0\ncmp指令比较了前后两个操作数的值，这里的DWORD PTR代表操作的数据类型是32位的整数，而[rbp-0x4]则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量r的值。第二个操作数0x0就是我们设定的常量0的16进制表示。cmp指令的比较结果，会存入到条件码寄存器当中去。\n在这里，如果比较的结果是False，也就是0，就把零标志条件码（对应的条件码是ZF，Zero Flag）设置为1。\ncmp指令执行完成之后，PC寄存器会自动自增，开始执行下一条jne的指令。\n对于：\njne 4a &lt;main+0x4a&gt;\njne指令，是jump if not equal的意思，它会查看对应的零标志位。如果为0，会跳转到后面跟着的操作数4a的位置。这个4a，对应这里汇编代码的行号，也就是上面设置的else条件里的第一条指令。\n当跳转发生的时候，PC寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的4a这个地址。这个时候，CPU再把4a地址里的指令加载到指令寄存器中来执行。\n4a: c7 45 f8 02 00 00 00     mov DWORD PTR [rbp-0x8],0x2 \n51: b8 00 00 00 00           mov eax,0x0\n\n4a的指令，实际是一条mov指令，第一个操作数和前面的cmp指令一样，是另一个32位整型的寄存器地址，以及对应的2的16进制值0x2。mov指令把2设置到对应的寄存器里去，相当于一个赋值操作。然后，PC寄存器里的值继续自增，执行下一条mov指令。\n下一条指令也是mov，第一个操作数eax，代表累加寄存器，第二个操作数0x0则是16进制的0的表示。这条指令其实没有实际的作用，它的作用是一个占位符。\n","slug":"计算机组成原理","date":"2022-07-05T07:02:41.000Z","categories_index":"","tags_index":"计组原、网络","author_index":"网工混子"}]
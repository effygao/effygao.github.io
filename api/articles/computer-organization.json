{"title":"计算机组成原理笔记","uid":"71ccfa0a8479931c66dcff584c51ed03","slug":"computer-organization","date":"2022-07-05T07:02:41.000Z","updated":"2022-07-05T08:16:16.898Z","comments":true,"path":"api/articles/computer-organization.json","keywords":null,"cover":[],"content":"<h4 id=\"CPU性能\"><a href=\"#CPU性能\" class=\"headerlink\" title=\"CPU性能\"></a>CPU性能</h4><p>响应时间：指的就是，我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。</p>\n<p>吞吐率：在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。</p>\n<p>我们一般把性能，定义成响应时间的倒数，也就是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">性能 &#x3D; 1&#x2F;响应时间<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"程序运行的时间\"><a href=\"#程序运行的时间\" class=\"headerlink\" title=\"程序运行的时间\"></a>程序运行的时间</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">程序运行的时间&#x3D;程序运行结束的时间-程序开始运行的时间<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>但是，计算机可能同时运行着好多个程序，CPU实际上不停地在各个程序之间进行切换。在这些走掉的时间里面，很可能CPU切换去运行别的程序了。所以这个时间并不准。</p>\n<p>我们使用time命令统计运行时间：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ time seq\n  1000000 | wc -l \n1000000 \nreal 0m0.101s \nuser 0m0.031s \nsys  0m0.016s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中real就是Wall Clock Time，而程序实际花费的CPU执行时间，就是user time加上sys time。</p>\n<p>我们下面对程序的CPU执行时间进行拆解：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">程序的CPU执行时间&#x3D;CPU时钟周期数×时钟周期时间<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>时钟周期时间：如果一台电脑的主频是2.8GHz，那么可以简单认为，CPU在1秒时间内，可以执行的简单指令的数量是2.8G条。在这个2.8GHz的CPU上，这个时钟周期时间，就是1&#x2F;2.8G。</p>\n<p>对于上面的公式：CPU时钟周期数还可以拆解成指令数×每条指令的平均时钟周期数Cycles Per Instruction，简称CPI）。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">程序的CPU执行时间&#x3D;指令数×CPI×Clock Cycle Time<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"并行优化\"><a href=\"#并行优化\" class=\"headerlink\" title=\"并行优化\"></a>并行优化</h4><p>由于通过提升CPU频率已经达到瓶颈，所以开始推出多核CPU，通过提升“吞吐率”而不是“响应时间”，来达到目的。</p>\n<p>但是，并不是所有问题，都可以通过并行提高性能来解决。如果想要使用这种思想，需要满足这样几个条件。</p>\n<p>1、需要进行的计算，本身可以分解成几个可以并行的任务。<br>2、需要能够分解好问题，并确保几个人的结果能够汇总到一起。<br>3、在“汇总”这个阶段，是没有办法并行进行的，还是得顺序执行，一步一步来。</p>\n<p>所以并行计算涉及到了一个阿姆达尔定律（Amdahl’s Law）。</p>\n<p>对于一个程序进行优化之后，处理器并行运算之后效率提升的情况。具体可以用这样一个公式来表示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">优化后的执行时间 &#x3D; 受优化影响的执行时间&#x2F;加速倍数+不受影响的执行时间<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>比如做一段数据的计算， 本来如果整个计算单核完成需要120ns，但是我们可以将这个任务拆分成4个，最后再汇总加起来。</p>\n<p>如果每个任务单独计算需要25ns，加起来汇总需要20ns，那么4个任务并行计算需要<strong>100&#x2F;4+20&#x3D;25ns</strong>。</p>\n<p>即使我们增加更多的并行度来提供加速倍数，比如有100个CPU，整个时间也需要<strong>100&#x2F;100+20&#x3D;21ns</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/effygao/picture/master/img/jzy-1.jpeg\"></p>\n<h4 id=\"从编译到汇编，代码怎么变成机器码？\"><a href=\"#从编译到汇编，代码怎么变成机器码？\" class=\"headerlink\" title=\"从编译到汇编，代码怎么变成机器码？\"></a>从编译到汇编，代码怎么变成机器码？</h4><p>如下C语言程序例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; test.cint main()&#123;\n  int a &#x3D; 1;\n  int b &#x3D; 2;\n  a &#x3D; a + b;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们给两个变量 a、b分别赋值1、2，然后再将a、b两个变量中的值加在一起，重新赋值给了a整个变量。</p>\n<p>要让这段程序在一个Linux操作系统上跑起来，我们需要把整个程序翻译成一个汇编语言（ASM，Assembly Language）的程序，这个过程我们一般叫编译（Compile）成汇编代码。</p>\n<p>针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）。这些机器码由“0”和“1”组成的机器语言表示。这一条条机器码，就是一条条的计算机指令。这样一串串的16进制数字，就是我们CPU能够真正认识的计算机指令。</p>\n<p><img src=\"https://raw.githubusercontent.com/effygao/picture/master/img/jzy-3.png\"></p>\n<p>汇编代码其实就是“给程序员看的机器码”，也正因为这样，机器码和汇编代码是一一对应的。我们人类很容易记住add、mov这些用英文表示的指令，而8b 45 f8这样的指令，由于很难一下子看明白是在干什么，所以会非常难以记忆。所以我们需要汇编代码。</p>\n<h4 id=\"指令是如何被执行的\"><a href=\"#指令是如何被执行的\" class=\"headerlink\" title=\"指令是如何被执行的\"></a>指令是如何被执行的</h4><p>一个CPU里面会有很多种不同功能的寄存器。我这里给你介绍三种比较特殊的。</p>\n<p>1、PC寄存器（Program Counter Register），也叫指令地址寄存器（Instruction Address Register）。它就是用来存放下一条需要执行的计算机指令的内存地址。</p>\n<p>2、指令寄存器（Instruction Register），用来存放当前正在执行的指令。</p>\n<p>3、条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放CPU进行算术或者逻辑计算的结果。</p>\n<p><img src=\"https://raw.githubusercontent.com/effygao/picture/master/img/zjy-3.jpeg\"></p>\n<p>实际上，一个程序执行的时候，CPU会根据PC寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。</p>\n<h4 id=\"程序的执行和跳转\"><a href=\"#程序的执行和跳转\" class=\"headerlink\" title=\"程序的执行和跳转\"></a>程序的执行和跳转</h4><p>现在就来看一个包含if…else的简单程序。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; test.c\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt; \nint main() &#123; \n    srand(time(NULL)); \n    int r &#x3D; rand() % 2; \n    int a &#x3D; 10; \n    if (r &#x3D;&#x3D; 0) &#123; \n        a &#x3D; 1; \n        &#125; else &#123; \n        a &#x3D; 2; \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>把这个程序编译成汇编代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if (r &#x3D;&#x3D; 0)\n3b: 83 7d fc 00     cmp DWORD PTR [rbp-0x4],0x0 \n3f: 75 09           jne 4a &lt;main+0x4a&gt;\n &#123;\n     a &#x3D; 1;\n41: c7 45 f8 01 00 00 00      mov DWORD PTR [rbp-0x8],0x1 \n48: eb 07                     jmp 51 &lt;main+0x51&gt;\n    &#125; \n    else \n    &#123;\n         a &#x3D; 2;\n4a: c7 45 f8 02 00 00 00   mov DWORD PTR [rbp-0x8],0x2\n51: b8 00 00 00 00         mov eax,0x0\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到，这里对于r &#x3D;&#x3D; 0的条件判断，被编译成了cmp和jne这两条指令。</p>\n<p>对于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cmp DWORD PTR [rbp-0x4],0x0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>cmp指令比较了前后两个操作数的值，这里的DWORD PTR代表操作的数据类型是32位的整数，而[rbp-0x4]则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量r的值。第二个操作数0x0就是我们设定的常量0的16进制表示。cmp指令的比较结果，会存入到条件码寄存器当中去。</p>\n<p>在这里，如果比较的结果是False，也就是0，就把零标志条件码（对应的条件码是ZF，Zero Flag）设置为1。</p>\n<p>cmp指令执行完成之后，PC寄存器会自动自增，开始执行下一条jne的指令。</p>\n<p>对于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">jne 4a &lt;main+0x4a&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>jne指令，是jump if not equal的意思，它会查看对应的零标志位。如果为0，会跳转到后面跟着的操作数4a的位置。这个4a，对应这里汇编代码的行号，也就是上面设置的else条件里的第一条指令。</p>\n<p>当跳转发生的时候，PC寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的4a这个地址。这个时候，CPU再把4a地址里的指令加载到指令寄存器中来执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">4a: c7 45 f8 02 00 00 00     mov DWORD PTR [rbp-0x8],0x2 \n51: b8 00 00 00 00           mov eax,0x0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>4a的指令，实际是一条mov指令，第一个操作数和前面的cmp指令一样，是另一个32位整型的寄存器地址，以及对应的2的16进制值0x2。mov指令把2设置到对应的寄存器里去，相当于一个赋值操作。然后，PC寄存器里的值继续自增，执行下一条mov指令。</p>\n<p>下一条指令也是mov，第一个操作数eax，代表累加寄存器，第二个操作数0x0则是16进制的0的表示。这条指令其实没有实际的作用，它的作用是一个占位符。</p>\n","text":"CPU性能响应时间：指的就是，我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。 吞吐率：在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。 我们一般把性能，定义成响应时间的倒数，也就是： 性能 &#x3D; 1...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"计组原、网络","slug":"计组原、网络","count":1,"path":"api/tags/计组原、网络.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CPU%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">CPU性能</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">程序运行的时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">并行优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%B1%87%E7%BC%96%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E6%9C%BA%E5%99%A8%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">从编译到汇编，代码怎么变成机器码？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84\"><span class=\"toc-text\">指令是如何被执行的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">程序的执行和跳转</span></a></li></ol>","author":{"name":"网工混子","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"如果没能一次成功，那就叫它1.0版吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":"https://github.com/effygao","zhihu":"https://www.zhihu.com/people/dreamland-81"}}},"mapped":true,"prev_post":{},"next_post":{}}